<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Floating Pixel Art</title>
  <link rel="icon" href="data:,">
  <script src="../lib/jquery-2.1.3.min.js"></script>
  <script src="../lib/base62.js"></script>
  <script src="../lib/qrcode.min.js"></script>
  <style>
    :root {
      --pixel-size: 40px; /* Size of each pixel in the grid */
      --grid-dimension: calc(var(--pixel-size) * 8); /* 8x8 grid */
      --safe-area-inset-top: env(safe-area-inset-top);
      --safe-area-inset-bottom: env(safe-area-inset-bottom);
    }
    html, body {
      height: 100%;
      margin: 0;
      background:#0f1115;
      color:#e7e9ee;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      padding-top: var(--safe-area-inset-top);
      padding-bottom: var(--safe-area-inset-bottom);
      box-sizing: border-box;
    }
    .stage {
      position: relative;
      width: var(--grid-dimension);
      height: var(--grid-dimension);
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      place-items: center;
      overflow: visible; /* Allow pixels to float outside */
      margin-bottom: 20px;
      border-radius: 12px;
    }
    .pixel {
      width: var(--pixel-size);
      height: var(--pixel-size);
      box-sizing: border-box;
      will-change: transform;
      transform: translate3d(0,0,0);
      border: 1px solid rgba(255,255,255,0.1); /* Subtle border for pixels */
      position: absolute; /* Allow free floating */
    }
    .hint {
      position: fixed; left: 12px; bottom: 12px; font-size: 14px; opacity: .7;
    }

    /* Color Classes - Must match draw page */
    .c0 { background-color: #FFFFFF; } /* White */
    .c1 { background-color: #000000; } /* Black */
    .c2 { background-color: #FFFF00; } /* Yellow */
    .c3 { background-color: #FF0000; } /* Red */
    .c4 { background-color: #0000FF; } /* Blue */
  </style>
</head>
<body>
  <div class="stage" id="stage">
    <!-- Pixels will be dynamically inserted here -->
  </div>
  <div class="hint">Pixels are floating freely!</div>

  <script>
    const stage = document.getElementById('stage');

    const PALETTE_COLORS = [
        '#FFFFFF', // c0 - White
        '#000000', // c1 - Black
        '#FFFF00', // c2 - Yellow
        '#FF0000', // c3 - Red
        '#0000FF'  // c4 - Blue
    ];

    let pixelElements = []; // To store all 64 pixel divs
    let pixelOffsets = []; // To store individual offsets for each pixel
    let pixelVelocities = []; // To store velocities for floating

    $(document).ready(function() {
        const urlParams = new URLSearchParams(window.location.search);
        const b62 = urlParams.get('b62');

        if (b62) {
            renderPixelArt(b62);
        } else {
            stage.innerHTML = '<p>그림 데이터가 없습니다.</p>';
        }

        tick(); // Start the floating animation loop
    });

    function renderPixelArt(b62String) {
        const decodedBigInt = base62.decode(b62String);
        const binaryString = decodedBigInt.toString(2).padStart(192, '0'); // 64 pixels * 3 bits = 192 bits

        stage.innerHTML = ''; // Clear existing content
        pixelElements = [];
        pixelOffsets = [];
        pixelVelocities = [];

        const pixelSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--pixel-size')) || 40;

        for (let i = 0; i < 64; i++) {
            const pixel = document.createElement('div');
            pixel.classList.add('pixel');

            const colorBits = binaryString.substring(i * 3, i * 3 + 3);
            const colorIndex = parseInt(colorBits, 2);
            pixel.classList.add(`c${colorIndex}`);
            
            // Position in grid
            const row = Math.floor(i / 8);
            const col = i % 8;
            pixel.style.left = `${col * pixelSize}px`;
            pixel.style.top = `${row * pixelSize}px`;
            
            pixelElements.push(pixel);
            stage.appendChild(pixel);

            // Initial offsets and velocities for floating
            pixelOffsets.push({
                x: 0,
                y: 0
            });
            pixelVelocities.push({
                x: (Math.random() - 0.5) * 2, // Random velocity
                y: (Math.random() - 0.5) * 2
            });
        }
    }

    // Floating animation loop
    function tick() {
        const time = Date.now() * 0.001; // Time in seconds

        pixelElements.forEach((pixel, index) => {
            const velocity = pixelVelocities[index];
            const offset = pixelOffsets[index];

            // Update position with sine waves for floating effect
            offset.x += velocity.x * 0.1;
            offset.y += velocity.y * 0.1;

            // Add some wave motion
            const waveX = Math.sin(time + index * 0.1) * 5;
            const waveY = Math.cos(time + index * 0.1) * 5;

            pixel.style.transform = `translate3d(${offset.x + waveX}px, ${offset.y + waveY}px, 0)`;

            // Bounce off edges (simple)
            const pixelSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--pixel-size')) || 40;
            const stageRect = stage.getBoundingClientRect();
            const pixelRect = pixel.getBoundingClientRect();

            if (pixelRect.left < stageRect.left || pixelRect.right > stageRect.right) {
                velocity.x *= -1;
            }
            if (pixelRect.top < stageRect.top || pixelRect.bottom > stageRect.bottom) {
                velocity.y *= -1;
            }
        });
        requestAnimationFrame(tick);
    }

    // 유틸
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  </script>
</body>
</html>